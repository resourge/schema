diff --git a/node_modules/vite-plugin-dts/dist/index.mjs b/node_modules/vite-plugin-dts/dist/index.mjs
index 70a9e60..6c0504c 100644
--- a/node_modules/vite-plugin-dts/dist/index.mjs
+++ b/node_modules/vite-plugin-dts/dist/index.mjs
@@ -24,325 +24,325 @@ import { PackageJsonLookup } from '@rushstack/node-core-library';
 
 const dtsRE$1 = /\.d\.tsx?$/;
 function rollupDeclarationFiles({
-  root,
-  configPath,
-  compilerOptions,
-  outDir,
-  entryPath,
-  fileName,
-  libFolder,
-  bundledPackages
+	root,
+	configPath,
+	compilerOptions,
+	outDir,
+	entryPath,
+	fileName,
+	libFolder,
+	bundledPackages
 }) {
-  const configObjectFullPath = resolve$1(root, "api-extractor.json");
-  const packageJsonLookup = new PackageJsonLookup();
-  const packageJsonFullPath = packageJsonLookup.tryGetPackageJsonFilePathFor(configObjectFullPath);
-  if (!dtsRE$1.test(fileName)) {
-    fileName += ".d.ts";
-  }
-  const extractorConfig = ExtractorConfig.prepare({
-    configObject: {
-      projectFolder: root,
-      mainEntryPointFilePath: entryPath,
-      bundledPackages,
-      compiler: {
-        tsconfigFilePath: configPath,
-        overrideTsconfig: {
-          $schema: "http://json.schemastore.org/tsconfig",
-          compilerOptions: {
-            ...compilerOptions,
-            target: "ESNext"
-          }
-        }
-      },
-      apiReport: {
-        enabled: false,
-        reportFileName: "<unscopedPackageName>.api.md"
-      },
-      docModel: {
-        enabled: false
-      },
-      dtsRollup: {
-        enabled: true,
-        publicTrimmedFilePath: resolve$1(outDir, fileName)
-      },
-      tsdocMetadata: {
-        enabled: false
-      },
-      messages: {
-        compilerMessageReporting: {
-          default: {
-            logLevel: "none"
-          }
-        },
-        extractorMessageReporting: {
-          default: {
-            logLevel: "none"
-          }
-        }
-      }
-    },
-    configObjectFullPath,
-    packageJsonFullPath
-  });
-  const compilerState = CompilerState.create(extractorConfig, {
-    localBuild: false,
-    showVerboseMessages: false,
-    typescriptCompilerFolder: libFolder ? resolve$1(libFolder) : void 0
-  });
-  const sourceMapper = new SourceMapper();
-  const messageRouter = new MessageRouter({
-    workingPackageFolder: root,
-    messageCallback: void 0,
-    messagesConfig: extractorConfig.messages,
-    showVerboseMessages: false,
-    showDiagnostics: false,
-    tsdocConfiguration: extractorConfig.tsdocConfiguration,
-    sourceMapper
-  });
-  const collector = new Collector({
-    program: compilerState.program,
-    messageRouter,
-    extractorConfig,
-    sourceMapper
-  });
-  collector.analyze();
-  DtsRollupGenerator.writeTypingsFile(
-    collector,
-    extractorConfig.publicTrimmedFilePath,
-    DtsRollupKind.PublicRelease,
-    extractorConfig.newlineKind
-  );
+	const configObjectFullPath = resolve$1(root, "api-extractor.json");
+	const packageJsonLookup = new PackageJsonLookup();
+	const packageJsonFullPath = packageJsonLookup.tryGetPackageJsonFilePathFor(configObjectFullPath);
+	if (!dtsRE$1.test(fileName)) {
+		fileName += ".d.ts";
+	}
+	const extractorConfig = ExtractorConfig.prepare({
+		configObject: {
+			projectFolder: root,
+			mainEntryPointFilePath: entryPath,
+			bundledPackages,
+			compiler: {
+				tsconfigFilePath: configPath,
+				overrideTsconfig: {
+					$schema: "http://json.schemastore.org/tsconfig",
+					compilerOptions: {
+						...compilerOptions,
+						target: "ESNext"
+					}
+				}
+			},
+			apiReport: {
+				enabled: false,
+				reportFileName: "<unscopedPackageName>.api.md"
+			},
+			docModel: {
+				enabled: false
+			},
+			dtsRollup: {
+				enabled: true,
+				publicTrimmedFilePath: resolve$1(outDir, fileName)
+			},
+			tsdocMetadata: {
+				enabled: false
+			},
+			messages: {
+				compilerMessageReporting: {
+					default: {
+						logLevel: "none"
+					}
+				},
+				extractorMessageReporting: {
+					default: {
+						logLevel: "none"
+					}
+				}
+			}
+		},
+		configObjectFullPath,
+		packageJsonFullPath
+	});
+	const compilerState = CompilerState.create(extractorConfig, {
+		localBuild: false,
+		showVerboseMessages: false,
+		typescriptCompilerFolder: libFolder ? resolve$1(libFolder) : void 0
+	});
+	const sourceMapper = new SourceMapper();
+	const messageRouter = new MessageRouter({
+		workingPackageFolder: root,
+		messageCallback: void 0,
+		messagesConfig: extractorConfig.messages,
+		showVerboseMessages: false,
+		showDiagnostics: false,
+		tsdocConfiguration: extractorConfig.tsdocConfiguration,
+		sourceMapper
+	});
+	const collector = new Collector({
+		program: compilerState.program,
+		messageRouter,
+		extractorConfig,
+		sourceMapper
+	});
+	collector.analyze();
+	DtsRollupGenerator.writeTypingsFile(
+		collector,
+		extractorConfig.publicTrimmedFilePath,
+		DtsRollupKind.PublicRelease,
+		extractorConfig.newlineKind
+	);
 }
 
 const jsonRE = /\.json$/;
 function JsonResolver() {
-  return {
-    name: "json",
-    supports(id) {
-      return jsonRE.test(id);
-    },
-    transform({ id, root, program }) {
-      const sourceFile = program.getSourceFile(id);
-      if (!sourceFile)
-        return [];
-      return [
-        {
-          path: relative(root, `${id}.d.ts`),
-          content: `declare const _default: ${sourceFile.text};
+	return {
+		name: "json",
+		supports(id) {
+			return jsonRE.test(id);
+		},
+		transform({ id, root, program }) {
+			const sourceFile = program.getSourceFile(id);
+			if (!sourceFile)
+				return [];
+			return [
+				{
+					path: relative(root, `${id}.d.ts`),
+					content: `declare const _default: ${sourceFile.text};
 
 export default _default;
 `
-        }
-      ];
-    }
-  };
+				}
+			];
+		}
+	};
 }
 
 const svelteRE = /\.svelte$/;
 function SvelteResolver() {
-  return {
-    name: "svelte",
-    supports(id) {
-      return svelteRE.test(id);
-    },
-    transform({ id, root }) {
-      return [
-        {
-          path: relative(root, `${id}.d.ts`),
-          content: "export { SvelteComponentTyped as default } from 'svelte';\n"
-        }
-      ];
-    }
-  };
+	return {
+		name: "svelte",
+		supports(id) {
+			return svelteRE.test(id);
+		},
+		transform({ id, root }) {
+			return [
+				{
+					path: relative(root, `${id}.d.ts`),
+					content: "export { SvelteComponentTyped as default } from 'svelte';\n"
+				}
+			];
+		}
+	};
 }
 
 const vueRE = /\.vue$/;
 function VueResolver() {
-  return {
-    name: "vue",
-    supports(id) {
-      return vueRE.test(id);
-    },
-    transform({ id, program, service }) {
-      const sourceFile = program.getSourceFile(id) || program.getSourceFile(id + ".ts") || program.getSourceFile(id + ".js") || program.getSourceFile(id + ".tsx") || program.getSourceFile(id + ".jsx");
-      if (!sourceFile)
-        return [];
-      return service.getEmitOutput(sourceFile.fileName, true).outputFiles.map((file) => {
-        return {
-          path: file.name,
-          content: file.text
-        };
-      });
-    }
-  };
+	return {
+		name: "vue",
+		supports(id) {
+			return vueRE.test(id);
+		},
+		transform({ id, program, service }) {
+			const sourceFile = program.getSourceFile(id) || program.getSourceFile(id + ".ts") || program.getSourceFile(id + ".js") || program.getSourceFile(id + ".tsx") || program.getSourceFile(id + ".jsx");
+			if (!sourceFile)
+				return [];
+			return service.getEmitOutput(sourceFile.fileName, true).outputFiles.map((file) => {
+				return {
+					path: file.name,
+					content: file.text
+				};
+			});
+		}
+	};
 }
 
 function parseResolvers(resolvers) {
-  const nameMap = /* @__PURE__ */ new Map();
-  for (const resolver of resolvers) {
-    resolver.name && nameMap.set(resolver.name, resolver);
-  }
-  return Array.from(nameMap.values());
+	const nameMap = /* @__PURE__ */ new Map();
+	for (const resolver of resolvers) {
+		resolver.name && nameMap.set(resolver.name, resolver);
+	}
+	return Array.from(nameMap.values());
 }
 
 const windowsSlashRE = /\\+/g;
 function slash(p) {
-  return p.replace(windowsSlashRE, "/");
+	return p.replace(windowsSlashRE, "/");
 }
 function normalizePath(id) {
-  return posix.normalize(slash(id));
+	return posix.normalize(slash(id));
 }
 function resolve(...paths) {
-  return normalizePath(resolve$1(...paths));
+	return normalizePath(resolve$1(...paths));
 }
 function isNativeObj(value) {
-  return Object.prototype.toString.call(value) === "[object Object]";
+	return Object.prototype.toString.call(value) === "[object Object]";
 }
 function isRegExp(value) {
-  return Object.prototype.toString.call(value) === "[object RegExp]";
+	return Object.prototype.toString.call(value) === "[object RegExp]";
 }
 function isPromise(value) {
-  return !!value && (typeof value === "function" || typeof value === "object") && typeof value.then === "function";
+	return !!value && (typeof value === "function" || typeof value === "object") && typeof value.then === "function";
 }
 function ensureAbsolute(path, root) {
-  return normalizePath(path ? isAbsolute(path) ? path : resolve(root, path) : root);
+	return normalizePath(path ? isAbsolute(path) ? path : resolve(root, path) : root);
 }
 function ensureArray(value) {
-  return Array.isArray(value) ? value : value ? [value] : [];
+	return Array.isArray(value) ? value : value ? [value] : [];
 }
 async function runParallel(maxConcurrency, source, iteratorFn) {
-  const ret = [];
-  const executing = [];
-  for (const item of source) {
-    const p = Promise.resolve().then(() => iteratorFn(item, source));
-    ret.push(p);
-    if (maxConcurrency <= source.length) {
-      const e = p.then(() => executing.splice(executing.indexOf(e), 1));
-      executing.push(e);
-      if (executing.length >= maxConcurrency) {
-        await Promise.race(executing);
-      }
-    }
-  }
-  return Promise.all(ret);
+	const ret = [];
+	const executing = [];
+	for (const item of source) {
+		const p = Promise.resolve().then(() => iteratorFn(item, source));
+		ret.push(p);
+		if (maxConcurrency <= source.length) {
+			const e = p.then(() => executing.splice(executing.indexOf(e), 1));
+			executing.push(e);
+			if (executing.length >= maxConcurrency) {
+				await Promise.race(executing);
+			}
+		}
+	}
+	return Promise.all(ret);
 }
 const speRE = /[\\/]/;
 function queryPublicPath(paths) {
-  if (paths.length === 0) {
-    return "";
-  } else if (paths.length === 1) {
-    return dirname(paths[0]);
-  }
-  let publicPath = normalize(dirname(paths[0])) + sep;
-  let publicUnits = publicPath.split(speRE);
-  let index = publicUnits.length - 1;
-  for (const path of paths.slice(1)) {
-    if (!index) {
-      return publicPath;
-    }
-    const dirPath = normalize(dirname(path)) + sep;
-    if (dirPath.startsWith(publicPath)) {
-      continue;
-    }
-    const units = dirPath.split(speRE);
-    if (units.length < index) {
-      publicPath = dirPath;
-      publicUnits = units;
-      continue;
-    }
-    for (let i = 0; i <= index; ++i) {
-      if (publicUnits[i] !== units[i]) {
-        if (!i) {
-          return "";
-        }
-        index = i - 1;
-        publicUnits = publicUnits.slice(0, index + 1);
-        publicPath = publicUnits.join(sep) + sep;
-        break;
-      }
-    }
-  }
-  return publicPath.slice(0, -1);
+	if (paths.length === 0) {
+		return "";
+	} else if (paths.length === 1) {
+		return dirname(paths[0]);
+	}
+	let publicPath = normalize(dirname(paths[0])) + sep;
+	let publicUnits = publicPath.split(speRE);
+	let index = publicUnits.length - 1;
+	for (const path of paths.slice(1)) {
+		if (!index) {
+			return publicPath;
+		}
+		const dirPath = normalize(dirname(path)) + sep;
+		if (dirPath.startsWith(publicPath)) {
+			continue;
+		}
+		const units = dirPath.split(speRE);
+		if (units.length < index) {
+			publicPath = dirPath;
+			publicUnits = units;
+			continue;
+		}
+		for (let i = 0; i <= index; ++i) {
+			if (publicUnits[i] !== units[i]) {
+				if (!i) {
+					return "";
+				}
+				index = i - 1;
+				publicUnits = publicUnits.slice(0, index + 1);
+				publicPath = publicUnits.join(sep) + sep;
+				break;
+			}
+		}
+	}
+	return publicPath.slice(0, -1);
 }
 function removeDirIfEmpty(dir) {
-  if (!existsSync(dir)) {
-    return;
-  }
-  let onlyHasDir = true;
-  for (const file of readdirSync(dir)) {
-    const abs = resolve(dir, file);
-    if (lstatSync(abs).isDirectory()) {
-      if (!removeDirIfEmpty(abs)) {
-        onlyHasDir = false;
-      }
-    } else {
-      onlyHasDir = false;
-    }
-  }
-  if (onlyHasDir) {
-    rmdirSync(dir);
-  }
-  return onlyHasDir;
+	if (!existsSync(dir)) {
+		return;
+	}
+	let onlyHasDir = true;
+	for (const file of readdirSync(dir)) {
+		const abs = resolve(dir, file);
+		if (lstatSync(abs).isDirectory()) {
+			if (!removeDirIfEmpty(abs)) {
+				onlyHasDir = false;
+			}
+		} else {
+			onlyHasDir = false;
+		}
+	}
+	if (onlyHasDir) {
+		rmdirSync(dir);
+	}
+	return onlyHasDir;
 }
 
 const globSuffixRE = /^((?:.*\.[^.]+)|(?:\*+))$/;
 function normalizeGlob(path) {
-  if (/[\\/]$/.test(path)) {
-    return path + "**";
-  } else if (!globSuffixRE.test(path.split(/[\\/]/).pop())) {
-    return path + "/**";
-  }
-  return path;
+	if (/[\\/]$/.test(path)) {
+		return path + "**";
+	} else if (!globSuffixRE.test(path.split(/[\\/]/).pop())) {
+		return path + "/**";
+	}
+	return path;
 }
 const globalDynamicTypeRE = /import\(['"][^;\n]+?['"]\)\.\w+[.()[\]<>,;\n\s]/g;
 const dynamicTypeRE = /import\(['"](.+)['"]\)\.(.+)([.()[\]<>,;\n\s])/;
 const importTypesRE = /import\s?(?:type)?\s?\{(.+)\}\s?from\s?['"].+['"]/;
 function transformDynamicImport(content) {
-  const importMap = /* @__PURE__ */ new Map();
-  const defaultMap = /* @__PURE__ */ new Map();
-  let defaultCount = 1;
-  content = content.replace(globalDynamicTypeRE, (str) => {
-    const matchResult = str.match(dynamicTypeRE);
-    const libName = matchResult[1];
-    const importSet = importMap.get(libName) ?? importMap.set(libName, /* @__PURE__ */ new Set()).get(libName);
-    let usedType = matchResult[2];
-    if (usedType === "default") {
-      usedType = defaultMap.get(libName) ?? defaultMap.set(libName, `__DTS_${defaultCount++}__`).get(libName);
-      importSet.add(`default as ${usedType}`);
-    } else {
-      importSet.add(usedType);
-    }
-    return usedType + matchResult[3];
-  });
-  importMap.forEach((importSet, libName) => {
-    const importReg = new RegExp(
-      `import\\s?(?:type)?\\s?\\{[^;\\n]+\\}\\s?from\\s?['"]${libName}['"]`,
-      "g"
-    );
-    const matchResult = content.match(importReg);
-    if (matchResult?.[0]) {
-      matchResult[0].match(importTypesRE)[1].trim().split(",").forEach((type) => {
-        type && importSet.add(type.trim());
-      });
-      content = content.replace(
-        matchResult[0],
-        `import { ${Array.from(importSet).join(", ")} } from '${libName}'`
-      );
-    } else {
-      content = `import { ${Array.from(importSet).join(", ")} } from '${libName}';
+	const importMap = /* @__PURE__ */ new Map();
+	const defaultMap = /* @__PURE__ */ new Map();
+	let defaultCount = 1;
+	content = content.replace(globalDynamicTypeRE, (str) => {
+		const matchResult = str.match(dynamicTypeRE);
+		const libName = matchResult[1];
+		const importSet = importMap.get(libName) ?? importMap.set(libName, /* @__PURE__ */ new Set()).get(libName);
+		let usedType = matchResult[2];
+		if (usedType === "default") {
+			usedType = defaultMap.get(libName) ?? defaultMap.set(libName, `__DTS_${defaultCount++}__`).get(libName);
+			importSet.add(`default as ${usedType}`);
+		} else {
+			importSet.add(usedType);
+		}
+		return usedType + matchResult[3];
+	});
+	importMap.forEach((importSet, libName) => {
+		const importReg = new RegExp(
+			`import\\s?(?:type)?\\s?\\{[^;\\n]+\\}\\s?from\\s?['"]${libName}['"]`,
+			"g"
+		);
+		const matchResult = content.match(importReg);
+		if (matchResult?.[0]) {
+			matchResult[0].match(importTypesRE)[1].trim().split(",").forEach((type) => {
+				type && importSet.add(type.trim());
+			});
+			content = content.replace(
+				matchResult[0],
+				`import { ${Array.from(importSet).join(", ")} } from '${libName}'`
+			);
+		} else {
+			content = `import { ${Array.from(importSet).join(", ")} } from '${libName}';
 ` + content;
-    }
-  });
-  return content;
+		}
+	});
+	return content;
 }
 function isAliasMatch(alias, importer) {
-  if (isRegExp(alias.find))
-    return alias.find.test(importer);
-  if (importer.length < alias.find.length)
-    return false;
-  if (importer === alias.find)
-    return true;
-  return importer.indexOf(alias.find) === 0 && (alias.find.endsWith("/") || importer.substring(alias.find.length)[0] === "/");
+	if (isRegExp(alias.find))
+		return alias.find.test(importer);
+	if (importer.length < alias.find.length)
+		return false;
+	if (importer === alias.find)
+		return true;
+	return importer.indexOf(alias.find) === 0 && (alias.find.endsWith("/") || importer.substring(alias.find.length)[0] === "/");
 }
 const globalImportRE = /(?:(?:import|export)\s?(?:type)?\s?(?:(?:\{[^;\n]+\})|(?:[^;\n]+))\s?from\s?['"][^;\n]+['"])|(?:import\(['"][^;\n]+?['"]\))/g;
 const staticImportRE = /(?:import|export)\s?(?:type)?\s?\{?.+\}?\s?from\s?['"](.+)['"]/;
@@ -350,37 +350,37 @@ const dynamicImportRE = /import\(['"]([^;\n]+?)['"]\)/;
 const simpleStaticImportRE = /((?:import|export).+from\s?)['"](.+)['"]/;
 const simpleDynamicImportRE = /(import\()['"](.+)['"]\)/;
 function transformAliasImport(filePath, content, aliases, exclude = []) {
-  if (!aliases.length)
-    return content;
-  return content.replace(globalImportRE, (str) => {
-    let matchResult = str.match(staticImportRE);
-    let isDynamic = false;
-    if (!matchResult) {
-      matchResult = str.match(dynamicImportRE);
-      isDynamic = true;
-    }
-    if (matchResult?.[1]) {
-      const matchedAlias = aliases.find((alias) => isAliasMatch(alias, matchResult[1]));
-      if (matchedAlias) {
-        if (exclude.some((e) => isRegExp(e) ? e.test(matchResult[1]) : String(e) === matchResult[1])) {
-          return str;
-        }
-        const truthPath = isAbsolute(matchedAlias.replacement) ? normalizePath(relative(dirname(filePath), matchedAlias.replacement)) : normalizePath(matchedAlias.replacement);
-        return str.replace(
-          isDynamic ? simpleDynamicImportRE : simpleStaticImportRE,
-          `$1'${matchResult[1].replace(
-            matchedAlias.find,
-            (truthPath.startsWith(".") ? truthPath : `./${truthPath}`) + (typeof matchedAlias.find === "string" && matchedAlias.find.endsWith("/") ? "/" : "")
-          )}'${isDynamic ? ")" : ""}`
-        );
-      }
-    }
-    return str;
-  });
+	if (!aliases.length)
+		return content;
+	return content.replace(globalImportRE, (str) => {
+		let matchResult = str.match(staticImportRE);
+		let isDynamic = false;
+		if (!matchResult) {
+			matchResult = str.match(dynamicImportRE);
+			isDynamic = true;
+		}
+		if (matchResult?.[1]) {
+			const matchedAlias = aliases.find((alias) => isAliasMatch(alias, matchResult[1]));
+			if (matchedAlias) {
+				if (exclude.some((e) => isRegExp(e) ? e.test(matchResult[1]) : String(e) === matchResult[1])) {
+					return str;
+				}
+				const truthPath = isAbsolute(matchedAlias.replacement) ? normalizePath(relative(dirname(filePath), matchedAlias.replacement)) : normalizePath(matchedAlias.replacement);
+				return str.replace(
+					isDynamic ? simpleDynamicImportRE : simpleStaticImportRE,
+					`$1'${matchResult[1].replace(
+						matchedAlias.find,
+						(truthPath.startsWith(".") ? truthPath : `./${truthPath}`) + (typeof matchedAlias.find === "string" && matchedAlias.find.endsWith("/") ? "/" : "")
+					)}'${isDynamic ? ")" : ""}`
+				);
+			}
+		}
+		return str;
+	});
 }
 const pureImportRE = /import\s?['"][^;\n]+?['"];?\n?/g;
 function removePureImport(content) {
-  return content.replace(pureImportRE, "");
+	return content.replace(pureImportRE, "");
 }
 
 const jsRE = /\.(m|c)?jsx?$/;
@@ -394,447 +394,452 @@ const defaultIndex = "index.d.ts";
 const logPrefix = cyan("[vite:dts]");
 const bundleDebug = debug("vite-plugin-dts:bundle");
 const fixedCompilerOptions = {
-  noEmit: false,
-  declaration: true,
-  emitDeclarationOnly: true,
-  noUnusedParameters: false,
-  checkJs: false,
-  skipLibCheck: true,
-  preserveSymlinks: false,
-  noEmitOnError: void 0,
-  target: ts.ScriptTarget.ESNext
+	noEmit: false,
+	declaration: true,
+	emitDeclarationOnly: true,
+	noUnusedParameters: false,
+	checkJs: false,
+	skipLibCheck: true,
+	preserveSymlinks: false,
+	noEmitOnError: void 0,
+	target: ts.ScriptTarget.ESNext
 };
 const noop = () => {
 };
 const extPrefix = (file) => mtjsRE.test(file) ? "m" : ctjsRE.test(file) ? "c" : "";
 function dtsPlugin(options = {}) {
-  const {
-    tsconfigPath,
-    logLevel,
-    staticImport = false,
-    clearPureImport = true,
-    cleanVueFileName = false,
-    insertTypesEntry = false,
-    rollupTypes = false,
-    bundledPackages = [],
-    pathsToAliases = true,
-    aliasesExclude = [],
-    copyDtsFiles = false,
-    strictOutput = true,
-    afterDiagnostic = noop,
-    beforeWriteFile = noop,
-    afterBuild = noop
-  } = options;
-  let root = ensureAbsolute(options.root ?? "", process.cwd());
-  let publicRoot = "";
-  let entryRoot = options.entryRoot ?? "";
-  let configPath;
-  let compilerOptions;
-  let rawCompilerOptions;
-  let outDirs;
-  let entries;
-  let include;
-  let exclude;
-  let aliases;
-  let libName;
-  let indexName;
-  let logger;
-  let host;
-  let program;
-  let filter;
-  let bundled = false;
-  let timeRecord = 0;
-  const resolvers = parseResolvers([
-    JsonResolver(),
-    VueResolver(),
-    SvelteResolver(),
-    ...options.resolvers || []
-  ]);
-  const rootFiles = /* @__PURE__ */ new Set();
-  const outputFiles = /* @__PURE__ */ new Map();
-  return {
-    name: "vite:dts",
-    apply: "build",
-    enforce: "pre",
-    config(config) {
-      const aliasOptions = config?.resolve?.alias ?? [];
-      if (isNativeObj(aliasOptions)) {
-        aliases = Object.entries(aliasOptions).map(([key, value]) => {
-          return { find: key, replacement: value };
-        });
-      } else {
-        aliases = ensureArray(aliasOptions);
-      }
-      if (aliasesExclude.length > 0) {
-        aliases = aliases.filter(
-          ({ find }) => !aliasesExclude.some(
-            (aliasExclude) => aliasExclude && (isRegExp(find) ? find.toString() === aliasExclude.toString() : isRegExp(aliasExclude) ? find.match(aliasExclude)?.[0] : find === aliasExclude)
-          )
-        );
-      }
-    },
-    async configResolved(config) {
-      logger = logLevel ? (await import('vite')).createLogger(logLevel, { allowClearScreen: config.clearScreen }) : config.logger;
-      root = ensureAbsolute(options.root ?? "", config.root);
-      if (config.build.lib) {
-        const input = typeof config.build.lib.entry === "string" ? [config.build.lib.entry] : config.build.lib.entry;
-        if (Array.isArray(input)) {
-          entries = input.reduce((prev, current) => {
-            prev[basename(current)] = current;
-            return prev;
-          }, {});
-        } else {
-          entries = { ...input };
-        }
-        const filename = config.build.lib.fileName ?? defaultIndex;
-        const entry = typeof config.build.lib.entry === "string" ? config.build.lib.entry : Object.values(config.build.lib.entry)[0];
-        libName = config.build.lib.name || "_default";
-        indexName = typeof filename === "string" ? filename : filename("es", entry);
-        if (!dtsRE.test(indexName)) {
-          indexName = `${indexName.replace(tjsRE, "")}.d.${extPrefix(indexName)}ts`;
-        }
-      } else {
-        logger.warn(
-          yellow(
-            `
+	const {
+		tsconfigPath,
+		logLevel,
+		staticImport = false,
+		clearPureImport = true,
+		cleanVueFileName = false,
+		insertTypesEntry = false,
+		rollupTypes = false,
+		bundledPackages = [],
+		pathsToAliases = true,
+		aliasesExclude = [],
+		copyDtsFiles = false,
+		strictOutput = true,
+		afterDiagnostic = noop,
+		beforeWriteFile = noop,
+		afterBuild = noop
+	} = options;
+	let root = ensureAbsolute(options.root ?? "", process.cwd());
+	let publicRoot = "";
+	let entryRoot = options.entryRoot ?? "";
+	let configPath;
+	let compilerOptions;
+	let rawCompilerOptions;
+	let outDirs;
+	let entries;
+	let include;
+	let exclude;
+	let aliases;
+	let libName;
+	let indexName;
+	let logger;
+	let host;
+	let program;
+	let filter;
+	let bundled = false;
+	let timeRecord = 0;
+	const resolvers = parseResolvers([
+		JsonResolver(),
+		VueResolver(),
+		SvelteResolver(),
+		...options.resolvers || []
+	]);
+	const rootFiles = /* @__PURE__ */ new Set();
+	const outputFiles = /* @__PURE__ */ new Map();
+	return {
+		name: "vite:dts",
+		apply: "build",
+		enforce: "pre",
+		config(config) {
+			const aliasOptions = config?.resolve?.alias ?? [];
+			if (isNativeObj(aliasOptions)) {
+				aliases = Object.entries(aliasOptions).map(([key, value]) => {
+					return { find: key, replacement: value };
+				});
+			} else {
+				aliases = ensureArray(aliasOptions);
+			}
+			if (aliasesExclude.length > 0) {
+				aliases = aliases.filter(
+					({ find }) => !aliasesExclude.some(
+						(aliasExclude) => aliasExclude && (isRegExp(find) ? find.toString() === aliasExclude.toString() : isRegExp(aliasExclude) ? find.match(aliasExclude)?.[0] : find === aliasExclude)
+					)
+				);
+			}
+		},
+		async configResolved(config) {
+			logger = logLevel ? (await import('vite')).createLogger(logLevel, { allowClearScreen: config.clearScreen }) : config.logger;
+			root = ensureAbsolute(options.root ?? "", config.root);
+			if (config.build.lib) {
+				const input = typeof config.build.lib.entry === "string" ? [config.build.lib.entry] : config.build.lib.entry;
+				if (Array.isArray(input)) {
+					entries = input.reduce((prev, current) => {
+						prev[basename(current)] = current;
+						return prev;
+					}, {});
+				} else {
+					entries = { ...input };
+				}
+				const filename = config.build.lib.fileName ?? defaultIndex;
+				const entry = typeof config.build.lib.entry === "string" ? config.build.lib.entry : Object.values(config.build.lib.entry)[0];
+				libName = config.build.lib.name || "_default";
+				indexName = typeof filename === "string" ? filename : filename("es", entry);
+				if (!dtsRE.test(indexName)) {
+					indexName = `${indexName.replace(tjsRE, "")}.d.${extPrefix(indexName)}ts`;
+				}
+			} else {
+				logger.warn(
+					yellow(
+						`
 ${cyan(
-              "[vite:dts]"
-            )} You are building a library that may not need to generate declaration files.
+							"[vite:dts]"
+						)} You are building a library that may not need to generate declaration files.
 `
-          )
-        );
-        libName = "_default";
-        indexName = defaultIndex;
-      }
-      if (!options.outDir) {
-        outDirs = [ensureAbsolute(config.build.outDir, root)];
-      }
-      bundleDebug("parse vite config");
-    },
-    options(options2) {
-      if (entries)
-        return;
-      const input = typeof options2.input === "string" ? [options2.input] : options2.input;
-      if (Array.isArray(input)) {
-        entries = input.reduce((prev, current) => {
-          prev[basename(current)] = current;
-          return prev;
-        }, {});
-      } else {
-        entries = { ...input };
-      }
-      logger = logger || console;
-      aliases = aliases || [];
-      libName = "_default";
-      indexName = defaultIndex;
-      bundleDebug("parse options");
-    },
-    async buildStart() {
-      if (program)
-        return;
-      bundleDebug("begin buildStart");
-      timeRecord = 0;
-      const startTime = Date.now();
-      configPath = tsconfigPath ? ensureAbsolute(tsconfigPath, root) : ts.findConfigFile(root, ts.sys.fileExists);
-      const content = configPath ? createParsedCommandLine(ts, ts.sys, configPath) : void 0;
-      compilerOptions = {
-        ...content?.options || {},
-        ...options.compilerOptions || {},
-        ...fixedCompilerOptions,
-        outDir: "."
-      };
-      rawCompilerOptions = content?.raw.compilerOptions || {};
-      if (!outDirs) {
-        outDirs = options.outDir ? ensureArray(options.outDir).map((d) => ensureAbsolute(d, root)) : [ensureAbsolute(content?.raw.compilerOptions?.outDir || "dist", root)];
-      }
-      const { baseUrl, paths } = compilerOptions;
-      if (pathsToAliases && baseUrl && paths) {
-        const basePath = ensureAbsolute(baseUrl, configPath ? dirname(configPath) : root);
-        const existsFinds = new Set(
-          aliases.map((alias) => alias.find).filter((find) => typeof find === "string")
-        );
-        for (const [findWithAsterisk, replacements] of Object.entries(paths)) {
-          const find = findWithAsterisk.replace("/*", "");
-          if (!replacements.length || existsFinds.has(find))
-            continue;
-          aliases.push({
-            find,
-            replacement: ensureAbsolute(replacements[0].replace("/*", ""), basePath)
-          });
-        }
-      }
-      include = ensureArray(options.include ?? content?.raw.include ?? "**/*").map(normalizeGlob);
-      exclude = ensureArray(options.exclude ?? content?.raw.exclude ?? "node_modules/**").map(
-        normalizeGlob
-      );
-      filter = createFilter(include, exclude, { resolve: root });
-      const rootNames = Object.values(entries).map((entry) => ensureAbsolute(entry, root)).concat(content?.fileNames.filter(filter) || []).map(normalizePath);
-      host = ts.createCompilerHost(compilerOptions, true);
-      program = createProgram({ host, rootNames, options: compilerOptions });
-      libName = libName || "_default";
-      indexName = indexName || defaultIndex;
-      const maybeEmitted = (sourceFile) => {
-        return !(compilerOptions.noEmitForJsFiles && jsRE.test(sourceFile.fileName)) && !sourceFile.isDeclarationFile && !program.isSourceFileFromExternalLibrary(sourceFile);
-      };
-      publicRoot = compilerOptions.rootDir ? ensureAbsolute(compilerOptions.rootDir, root) : compilerOptions.composite && compilerOptions.configFilePath ? dirname(compilerOptions.configFilePath) : queryPublicPath(
-        program.getSourceFiles().filter(maybeEmitted).map((sourceFile) => sourceFile.fileName)
-      );
-      publicRoot = normalizePath(publicRoot);
-      entryRoot = entryRoot || publicRoot;
-      entryRoot = ensureAbsolute(entryRoot, root);
-      const diagnostics = program.getDeclarationDiagnostics();
-      if (diagnostics?.length) {
-        logger.error(ts.formatDiagnostics(diagnostics, host));
-      }
-      if (typeof afterDiagnostic === "function") {
-        const result = afterDiagnostic(diagnostics);
-        isPromise(result) && await result;
-      }
-      rootNames.forEach((file) => {
-        this.addWatchFile(file);
-        rootFiles.add(file);
-      });
-      bundleDebug("create ts program");
-      timeRecord += Date.now() - startTime;
-    },
-    async transform(code, id) {
-      let resolver;
-      id = normalizePath(id).split("?")[0];
-      if (!host || !program || !filter(id) || !(resolver = resolvers.find((r) => r.supports(id))) && !tjsRE.test(id)) {
-        return;
-      }
-      const startTime = Date.now();
-      const outDir = outDirs[0];
-      const service = program.__vue.languageService;
-      rootFiles.delete(id);
-      if (resolver) {
-        const result = await resolver.transform({
-          id,
-          code,
-          root: publicRoot,
-          outDir,
-          host,
-          program,
-          service
-        });
-        for (const { path, content } of result) {
-          outputFiles.set(
-            resolve(publicRoot, relative(outDir, ensureAbsolute(path, outDir))),
-            content
-          );
-        }
-      } else {
-        const sourceFile = program.getSourceFile(id);
-        if (sourceFile) {
-          for (const outputFile of service.getEmitOutput(sourceFile.fileName, true).outputFiles) {
-            outputFiles.set(
-              resolve(publicRoot, relative(outDir, ensureAbsolute(outputFile.name, outDir))),
-              outputFile.text
-            );
-          }
-        }
-      }
-      const dtsId = id.replace(tjsRE, "") + ".d.ts";
-      const dtsSourceFile = program.getSourceFile(dtsId);
-      dtsSourceFile && filter(dtsSourceFile.fileName) && outputFiles.set(normalizePath(dtsSourceFile.fileName), dtsSourceFile.getFullText());
-      timeRecord += Date.now() - startTime;
-    },
-    watchChange(id) {
-      id = normalizePath(id).split("?")[0];
-      if (!host || !program || !filter(id) || !resolvers.find((r) => r.supports(id)) && !tjsRE.test(id)) {
-        return;
-      }
-      const sourceFile = host.getSourceFile(normalizePath(id), ts.ScriptTarget.ESNext);
-      if (sourceFile) {
-        rootFiles.add(sourceFile.fileName);
-        program.__vue.projectVersion++;
-        bundled = false;
-        timeRecord = 0;
-      }
-    },
-    async writeBundle() {
-      if (!program || bundled)
-        return;
-      bundled = true;
-      bundleDebug("begin writeBundle");
-      logger.info(green(`
+					)
+				);
+				libName = "_default";
+				indexName = defaultIndex;
+			}
+			if (!options.outDir) {
+				outDirs = [ensureAbsolute(config.build.outDir, root)];
+			}
+			bundleDebug("parse vite config");
+		},
+		options(options2) {
+			if (entries)
+				return;
+			const input = typeof options2.input === "string" ? [options2.input] : options2.input;
+			if (Array.isArray(input)) {
+				entries = input.reduce((prev, current) => {
+					prev[basename(current)] = current;
+					return prev;
+				}, {});
+			} else {
+				entries = { ...input };
+			}
+			logger = logger || console;
+			aliases = aliases || [];
+			libName = "_default";
+			indexName = defaultIndex;
+			bundleDebug("parse options");
+		},
+		async buildStart() {
+			if (program)
+				return;
+			bundleDebug("begin buildStart");
+			timeRecord = 0;
+			const startTime = Date.now();
+			configPath = tsconfigPath ? ensureAbsolute(tsconfigPath, root) : ts.findConfigFile(root, ts.sys.fileExists);
+			const content = configPath ? createParsedCommandLine(ts, ts.sys, configPath) : void 0;
+			compilerOptions = {
+				...content?.options || {},
+				...options.compilerOptions || {},
+				...fixedCompilerOptions,
+				outDir: "."
+			};
+			rawCompilerOptions = content?.raw.compilerOptions || {};
+			if (!outDirs) {
+				outDirs = options.outDir ? ensureArray(options.outDir).map((d) => ensureAbsolute(d, root)) : [ensureAbsolute(content?.raw.compilerOptions?.outDir || "dist", root)];
+			}
+			const { baseUrl, paths } = compilerOptions;
+			if (pathsToAliases && baseUrl && paths) {
+				const basePath = ensureAbsolute(baseUrl, configPath ? dirname(configPath) : root);
+				const existsFinds = new Set(
+					aliases.map((alias) => alias.find).filter((find) => typeof find === "string")
+				);
+				for (const [findWithAsterisk, replacements] of Object.entries(paths)) {
+					const find = findWithAsterisk.replace("/*", "");
+					if (!replacements.length || existsFinds.has(find))
+						continue;
+					aliases.push({
+						find,
+						replacement: ensureAbsolute(replacements[0].replace("/*", ""), basePath)
+					});
+				}
+			}
+			include = ensureArray(options.include ?? content?.raw.include ?? "**/*").map(normalizeGlob);
+			exclude = ensureArray(options.exclude ?? content?.raw.exclude ?? "node_modules/**").map(
+				normalizeGlob
+			);
+			filter = createFilter(include, exclude, { resolve: root });
+			const rootNames = Object.values(entries).map((entry) => ensureAbsolute(entry, root)).concat(content?.fileNames.filter(filter) || []).map(normalizePath);
+			host = ts.createCompilerHost(compilerOptions, true);
+			program = createProgram({ host, rootNames, options: compilerOptions });
+			libName = libName || "_default";
+			indexName = indexName || defaultIndex;
+			const maybeEmitted = (sourceFile) => {
+				return !(compilerOptions.noEmitForJsFiles && jsRE.test(sourceFile.fileName)) && !sourceFile.isDeclarationFile && !program.isSourceFileFromExternalLibrary(sourceFile);
+			};
+			publicRoot = compilerOptions.rootDir ? ensureAbsolute(compilerOptions.rootDir, root) : compilerOptions.composite && compilerOptions.configFilePath ? dirname(compilerOptions.configFilePath) : queryPublicPath(
+				program.getSourceFiles().filter(maybeEmitted).map((sourceFile) => sourceFile.fileName)
+			);
+			publicRoot = normalizePath(publicRoot);
+			entryRoot = entryRoot || publicRoot;
+			entryRoot = ensureAbsolute(entryRoot, root);
+			const diagnostics = program.getDeclarationDiagnostics();
+			if (diagnostics?.length) {
+				logger.error(ts.formatDiagnostics(diagnostics, host));
+			}
+			if (typeof afterDiagnostic === "function") {
+				const result = afterDiagnostic(diagnostics);
+				isPromise(result) && await result;
+			}
+			rootNames.forEach((file) => {
+				this.addWatchFile(file);
+				rootFiles.add(file);
+			});
+			bundleDebug("create ts program");
+			timeRecord += Date.now() - startTime;
+		},
+		async transform(code, id) {
+			let resolver;
+			id = normalizePath(id).split("?")[0];
+			if (!host || !program || !filter(id) || !(resolver = resolvers.find((r) => r.supports(id))) && !tjsRE.test(id)) {
+				return;
+			}
+			const startTime = Date.now();
+			const outDir = outDirs[0];
+			const service = program.__vue.languageService;
+			rootFiles.delete(id);
+			if (resolver) {
+				const result = await resolver.transform({
+					id,
+					code,
+					root: publicRoot,
+					outDir,
+					host,
+					program,
+					service
+				});
+				for (const { path, content } of result) {
+					outputFiles.set(
+						resolve(publicRoot, relative(outDir, ensureAbsolute(path, outDir))),
+						content
+					);
+				}
+			} else {
+				const sourceFile = program.getSourceFile(id);
+				if (sourceFile) {
+					for (const outputFile of service.getEmitOutput(sourceFile.fileName, true).outputFiles) {
+						outputFiles.set(
+							resolve(publicRoot, relative(outDir, ensureAbsolute(outputFile.name, outDir))),
+							outputFile.text
+						);
+					}
+				}
+			}
+			const dtsId = id.replace(tjsRE, "") + ".d.ts";
+			const dtsSourceFile = program.getSourceFile(dtsId);
+			dtsSourceFile && filter(dtsSourceFile.fileName) && outputFiles.set(normalizePath(dtsSourceFile.fileName), dtsSourceFile.getFullText());
+			timeRecord += Date.now() - startTime;
+		},
+		watchChange(id) {
+			id = normalizePath(id).split("?")[0];
+			if (!host || !program || !filter(id) || !resolvers.find((r) => r.supports(id)) && !tjsRE.test(id)) {
+				return;
+			}
+			const sourceFile = host.getSourceFile(normalizePath(id), ts.ScriptTarget.ESNext);
+			if (sourceFile) {
+				rootFiles.add(sourceFile.fileName);
+				program.__vue.projectVersion++;
+				bundled = false;
+				timeRecord = 0;
+			}
+		},
+		async writeBundle() {
+			if (!program || bundled)
+				return;
+			bundled = true;
+			bundleDebug("begin writeBundle");
+			logger.info(green(`
 ${logPrefix} Start generate declaration files...`));
-      const startTime = Date.now();
-      const outDir = outDirs[0];
-      const emittedFiles = /* @__PURE__ */ new Map();
-      const writeOutput = async (path, content, outDir2) => {
-        path = normalizePath(path);
-        const dir = normalizePath(dirname(path));
-        if (strictOutput && !dir.startsWith(normalizePath(outDir2))) {
-          logger.warn(`${logPrefix} ${yellow("Outside emitted:")} ${path}`);
-          return;
-        }
-        if (!existsSync(dir)) {
-          await mkdir(dir, { recursive: true });
-        }
-        await writeFile(path, content, "utf-8");
-        emittedFiles.set(path, content);
-      };
-      const service = program.__vue.languageService;
-      const sourceFiles = program.getSourceFiles();
-      for (const sourceFile of sourceFiles) {
-        if (!filter(sourceFile.fileName))
-          continue;
-        if (copyDtsFiles && dtsRE.test(sourceFile.fileName)) {
-          outputFiles.set(normalizePath(sourceFile.fileName), sourceFile.getFullText());
-        }
-        if (rootFiles.has(sourceFile.fileName)) {
-          for (const outputFile of service.getEmitOutput(sourceFile.fileName, true).outputFiles) {
-            outputFiles.set(
-              resolve(publicRoot, relative(outDir, ensureAbsolute(outputFile.name, outDir))),
-              outputFile.text
-            );
-          }
-          rootFiles.delete(sourceFile.fileName);
-        }
-      }
-      bundleDebug("emit output patch");
-      await runParallel(
-        cpus().length,
-        Array.from(outputFiles.entries()),
-        async ([path, content]) => {
-          const isMapFile = path.endsWith(".map");
-          if (!isMapFile && content) {
-            content = clearPureImport ? removePureImport(content) : content;
-            content = transformAliasImport(path, content, aliases, aliasesExclude);
-            content = staticImport || rollupTypes ? transformDynamicImport(content) : content;
-          }
-          path = resolve(
-            outDir,
-            relative(entryRoot, cleanVueFileName ? path.replace(".vue.d.ts", ".d.ts") : path)
-          );
-          content = cleanVueFileName ? content.replace(/['"](.+)\.vue['"]/g, '"$1"') : content;
-          if (typeof beforeWriteFile === "function") {
-            const result = beforeWriteFile(path, content);
-            if (result === false)
-              return;
-            if (result && isNativeObj(result)) {
-              path = result.filePath || path;
-              content = result.content ?? content;
-            }
-          }
-          await writeOutput(path, content, outDir);
-        }
-      );
-      bundleDebug("write output");
-      if (insertTypesEntry || rollupTypes) {
-        const pkgPath = resolve(root, "package.json");
-        const pkg = existsSync(pkgPath) ? JSON.parse(await readFile(pkgPath, "utf-8")) : {};
-        const entryNames = Object.keys(entries);
-        const types = pkg.types || pkg.typings || pkg.publishConfig?.types || pkg.publishConfig?.typings || (pkg.exports?.["."] || pkg.exports?.["./"])?.types;
-        const multiple = entryNames.length > 1;
-        const typesPath = types ? resolve(root, types) : resolve(outDir, indexName);
-        for (const name of entryNames) {
-          let path = multiple ? resolve(outDir, `${name.replace(tsRE, "")}.d.ts`) : typesPath;
-          if (existsSync(path))
-            continue;
-          const index = resolve(
-            outDir,
-            relative(entryRoot, `${entries[name].replace(tsRE, "")}.d.ts`)
-          );
-          let fromPath = normalizePath(relative(dirname(path), index));
-          fromPath = fromPath.replace(dtsRE, "");
-          fromPath = fullRelativeRE.test(fromPath) ? fromPath : `./${fromPath}`;
-          let content = `export * from '${fromPath}'
+			const startTime = Date.now();
+			const outDir = outDirs[0];
+			const emittedFiles = /* @__PURE__ */ new Map();
+			const writeOutput = async (path, content, outDir2) => {
+				path = normalizePath(path);
+				const dir = normalizePath(dirname(path));
+				if (strictOutput && !dir.startsWith(normalizePath(outDir2))) {
+					logger.warn(`${logPrefix} ${yellow("Outside emitted:")} ${path}`);
+					return;
+				}
+				if (!existsSync(dir)) {
+					await mkdir(dir, { recursive: true });
+				}
+				await writeFile(path, content, "utf-8");
+				emittedFiles.set(path, content);
+			};
+			const service = program.__vue.languageService;
+			const sourceFiles = program.getSourceFiles();
+			for (const sourceFile of sourceFiles) {
+				if (!filter(sourceFile.fileName))
+					continue;
+				if (copyDtsFiles && dtsRE.test(sourceFile.fileName)) {
+					outputFiles.set(normalizePath(sourceFile.fileName), sourceFile.getFullText());
+				}
+				if (rootFiles.has(sourceFile.fileName)) {
+					for (const outputFile of service.getEmitOutput(sourceFile.fileName, true).outputFiles) {
+						outputFiles.set(
+							resolve(publicRoot, relative(outDir, ensureAbsolute(outputFile.name, outDir))),
+							outputFile.text
+						);
+					}
+					rootFiles.delete(sourceFile.fileName);
+				}
+			}
+			bundleDebug("emit output patch");
+			await runParallel(
+				cpus().length,
+				Array.from(outputFiles.entries()),
+				async ([path, content]) => {
+					const isMapFile = path.endsWith(".map");
+					if (!isMapFile && content) {
+						content = clearPureImport ? removePureImport(content) : content;
+						content = transformAliasImport(path, content, aliases, aliasesExclude);
+						content = staticImport || rollupTypes ? transformDynamicImport(content) : content;
+					}
+					path = resolve(
+						outDir,
+						relative(entryRoot, cleanVueFileName ? path.replace(".vue.d.ts", ".d.ts") : path)
+					);
+					content = cleanVueFileName ? content.replace(/['"](.+)\.vue['"]/g, '"$1"') : content;
+					if (typeof beforeWriteFile === "function") {
+						const result = beforeWriteFile(path, content);
+						if (result === false)
+							return;
+						if (result && isNativeObj(result)) {
+							path = result.filePath || path;
+							content = result.content ?? content;
+						}
+					}
+					await writeOutput(path, content, outDir);
+				}
+			);
+			bundleDebug("write output");
+			if (insertTypesEntry || rollupTypes) {
+				const pkgPath = resolve(root, "package.json");
+				const pkg = existsSync(pkgPath) ? JSON.parse(await readFile(pkgPath, "utf-8")) : {};
+				const entryNames = Object.keys(entries);
+				const types = pkg.types || pkg.typings || pkg.publishConfig?.types || pkg.publishConfig?.typings || (pkg.exports?.["."] || pkg.exports?.["./"])?.types;
+				const multiple = entryNames.length > 1;
+				const typesPath = types ? resolve(root, types) : resolve(outDir, indexName);
+				for (const name of entryNames) {
+					let path = multiple ? resolve(outDir, `${name.replace(tsRE, "")}.d.ts`) : typesPath;
+
+					if (existsSync(path))
+						continue;
+					const index = resolve(
+						outDir,
+						relative(entryRoot, `${entries[name].replace(tsRE, "")}.d.ts`)
+					);
+
+					let fromPath = normalizePath(relative(dirname(path), index));
+					fromPath = fromPath.replace(dtsRE, "");
+					fromPath = fullRelativeRE.test(fromPath) ? fromPath : `./${fromPath}`;
+					let content = `export * from '${fromPath}'
 `;
-          if (existsSync(index)) {
-            const entryCodes = await readFile(index, "utf-8");
-            if (entryCodes.includes("export default")) {
-              content += `import ${libName} from '${fromPath}'
+					if (existsSync(index)) {
+						const entryCodes = await readFile(index, "utf-8");
+						if (entryCodes.includes("export default")) {
+							content += `import ${libName} from '${fromPath}'
 export default ${libName}
 `;
-            }
-          }
-          if (typeof beforeWriteFile === "function") {
-            const result = beforeWriteFile(path, content);
-            if (result === false)
-              return;
-            if (result && isNativeObj(result)) {
-              path = result.filePath ?? path;
-              content = result.content ?? content;
-            }
-          }
-          await writeOutput(path, content, outDir);
-        }
-        bundleDebug("insert index");
-        if (rollupTypes) {
-          logger.info(green(`${logPrefix} Start rollup declaration files...`));
-          let libFolder = resolve(root, "node_modules/typescript");
-          if (!existsSync(libFolder)) {
-            if (root !== entryRoot) {
-              libFolder = resolve(entryRoot, "node_modules/typescript");
-              if (!existsSync(libFolder))
-                libFolder = void 0;
-            }
-            libFolder = void 0;
-          }
-          const rollupFiles = /* @__PURE__ */ new Set();
-          if (multiple) {
-            for (const name of entryNames) {
-              const path = resolve(outDir, `${name.replace(tsRE, "")}.d.ts`);
-              rollupDeclarationFiles({
-                root,
-                configPath,
-                compilerOptions: rawCompilerOptions,
-                outDir,
-                entryPath: path,
-                fileName: basename(path),
-                libFolder,
-                bundledPackages
-              });
-              emittedFiles.delete(path);
-              rollupFiles.add(path);
-            }
-          } else {
-            rollupDeclarationFiles({
-              root,
-              configPath,
-              compilerOptions: rawCompilerOptions,
-              outDir,
-              entryPath: typesPath,
-              fileName: basename(typesPath),
-              libFolder,
-              bundledPackages
-            });
-            emittedFiles.delete(typesPath);
-            rollupFiles.add(typesPath);
-          }
-          await runParallel(cpus().length, Array.from(emittedFiles.keys()), (f) => unlink(f));
-          removeDirIfEmpty(outDir);
-          emittedFiles.clear();
-          for (const file of rollupFiles) {
-            emittedFiles.set(file, await readFile(file, "utf-8"));
-          }
-          bundleDebug("rollup output");
-        }
-      }
-      if (outDirs.length > 1) {
-        const extraOutDirs = outDirs.slice(1);
-        await runParallel(cpus().length, Array.from(emittedFiles), async ([wroteFile, content]) => {
-          const relativePath = relative(outDir, wroteFile);
-          await Promise.all(
-            extraOutDirs.map(async (outDir2) => {
-              await writeOutput(resolve(outDir2, relativePath), content, outDir2);
-            })
-          );
-        });
-      }
-      if (typeof afterBuild === "function") {
-        const result = afterBuild();
-        isPromise(result) && await result;
-      }
-      bundleDebug("finish");
-      logger.info(
-        green(`${logPrefix} Declaration files built in ${timeRecord + Date.now() - startTime}ms.
+						}
+					}
+					if (typeof beforeWriteFile === "function") {
+						const result = beforeWriteFile(path, content);
+						if (result === false)
+							return;
+						if (result && isNativeObj(result)) {
+							path = result.filePath ?? path;
+							content = result.content ?? content;
+						}
+					}
+					await writeOutput(path, content, outDir);
+				}
+				bundleDebug("insert index");
+				if (rollupTypes) {
+					logger.info(green(`${logPrefix} Start rollup declaration files...`));
+					let libFolder = resolve(root, "node_modules/typescript");
+					if (!existsSync(libFolder)) {
+						if (root !== entryRoot) {
+							libFolder = resolve(entryRoot, "node_modules/typescript");
+							if (!existsSync(libFolder))
+								libFolder = void 0;
+						}
+						libFolder = void 0;
+					}
+					const rollupFiles = /* @__PURE__ */ new Set();
+					if (multiple) {
+						for (const name of entryNames) {
+							const path = resolve(outDir, `${name.replace(tsRE, "")}.d.ts`);
+
+							rollupDeclarationFiles({
+								root,
+								configPath,
+								compilerOptions: rawCompilerOptions,
+								outDir,
+								entryPath: path,
+								fileName: path,
+								libFolder,
+								bundledPackages
+							});
+							emittedFiles.delete(path);
+							rollupFiles.add(path);
+						}
+					} else {
+
+
+						rollupDeclarationFiles({
+							root,
+							configPath,
+							compilerOptions: rawCompilerOptions,
+							outDir,
+							entryPath: typesPath,
+							fileName: basename(typesPath),
+							libFolder,
+							bundledPackages
+						});
+						emittedFiles.delete(typesPath);
+						rollupFiles.add(typesPath);
+					}
+					await runParallel(cpus().length, Array.from(emittedFiles.keys()), (f) => unlink(f));
+					removeDirIfEmpty(outDir);
+					emittedFiles.clear();
+					for (const file of rollupFiles) {
+						emittedFiles.set(file, await readFile(file, "utf-8"));
+					}
+					bundleDebug("rollup output");
+				}
+			}
+			if (outDirs.length > 1) {
+				const extraOutDirs = outDirs.slice(1);
+				await runParallel(cpus().length, Array.from(emittedFiles), async ([wroteFile, content]) => {
+					const relativePath = relative(outDir, wroteFile);
+					await Promise.all(
+						extraOutDirs.map(async (outDir2) => {
+							await writeOutput(resolve(outDir2, relativePath), content, outDir2);
+						})
+					);
+				});
+			}
+			if (typeof afterBuild === "function") {
+				const result = afterBuild();
+				isPromise(result) && await result;
+			}
+			bundleDebug("finish");
+			logger.info(
+				green(`${logPrefix} Declaration files built in ${timeRecord + Date.now() - startTime}ms.
 `)
-      );
-    }
-  };
+			);
+		}
+	};
 }
 
 export { dtsPlugin as default };
